# 7、Functions: C++’s Programming Modules 







### Tips:

* C++对函数返回值的限制：不能是**数组**。
* 如果函数包含多条返回语句，那么函数在执行遇到的第一条返回语句后结束。
* **函数原型**告诉编译器返回值的类型便于编译器知道应该检索多少个字节以及如何解释它们。
* 函数原型不要求提供变量名，有类型就足够了。
* 函数原型确保以下几点：
  * 编译器正确处理函数返回值；
  * 编译器检查使用的参数数目是否正确；
  * 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型。
* **静态类型检查（static type checking）**： 在编译阶段进行的原型化。
* 在C++中，当且仅当用于函数头或函数原型中，int* arr 和int arr[]的含义才相同。
* sizeof 还可以这样使用 ： **sizeof  arr;**
* 由于接受数组名参数的函数访问的是原始数组，而不是其副本，因此可以同过调用该函数将值赋给数组元素。
* 将const变量的地址赋给指向const的指针可行；将const的地址赋给常量指针不可行。C++禁止将const的地址赋给非const指针。
* 将指针参数声明为指向常量数据的指针有两条理由

  * 这样可以避免由于无意间修改数据而导致编程错误；
  * 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。
* 通常，将指针作为函数参数来传递时，可以使用指向const的指针来保护数据。
* 将字符串作为参数来传递，传递的事迹时字符串的第一个字符地址。
* 假设要将字符串作为参数传递给函数，则表示字符串的方式有三种：
  * char数组
  * 用引号括起来的字符串常量
  * 被设置为字符串的地址的char指针
* 与数据项相似，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。
* 函数名可以获得函数的地址，例如：think是think()的地址。 
* 声明指向函数的指针时，也必须指定指针指向的函数类型。这意味着声明应指定函数的返回类型以及函数的特征标（参数列表）。也就是说，声明应像函数原型那样指出有关函数的信息。
* 通常，要生命指向特定类型的函数的指针，可以首先编写这种函数的原型，然后用（*pf）替换函数名。这样pf就是这类函数的指针。
* **容忍逻辑上无法自圆其说的观点是人类思维活动的终点。**
* C++11 的目标之一是让C++容易使用，从而让程序员将主要的精力放在设计而不是细节上。
* 自动类型推断功能有一个潜在的缺点，自动类型推断确保变量的类型与赋给它的初值的类型一致，但我们提供的初值的类型可能不对。

